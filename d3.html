<!DOCTYPE html>
<html>
<head>
    <script src="d3.min.js"></script>
</head>
<body>
    <div id="container"></div>
</body>

<script>
    // https://observablehq.com/@d3/selection-join
    
    // ==== LIB ====
    var _promiseTimeouts = new Map;
    // TODO: pull in width as well
    
    
    function* now() {
        while (true) {  yield Date.now(); }
    }
    
    function constant(x) { return function() { return x; }; }
    
    function _whenTimeout(now, time) {
        var t = new Promise(function(resolve) {
            _promiseTimeouts.delete(time);
            var delay = time - now;
            if (!(delay > 0)) throw new Error("invalid time");
            if (delay > 0x7fffffff) throw new Error("too long to wait");
            setTimeout(resolve, delay);
        });
        _promiseTimeouts.set(time, t);
        return t;
    }
    
    function promiseWhen(time, value) {
        var now;
        return (now = _promiseTimeouts.get(time = +time)) ? now.then(constant(value))
        : (now = Date.now()) >= time ? Promise.resolve(value)
        : _whenTimeout(now, time).then(constant(value));
    }
    
    function promiseTick(duration, value) {
        return promiseWhen(Math.ceil((Date.now() + 1) / duration) * duration, value);
    }
    
    function promiseDelay(duration, value) {
        return new Promise(function(resolve) {
            setTimeout(function() {
                resolve(value);
            }, duration);
        });
    }
    
    
    function randomLetters() {
        return d3.shuffle("abcdefghijklmnopqrstuvwxyz".split(""))
        .slice(0, Math.floor(6 + Math.random() * 20))
        .sort();
    }
    const width = 400;
    
    async function* f() {
        const svg = d3.create("svg")
        .attr("width", width)
        .attr("height", 33)
        .attr("viewBox", `0 -20 ${width} 33`);
        
        while (true) {
            svg.selectAll("text")
            .data(randomLetters())
            .join("text")
            .attr("x", (d, i) => i * 16)
            .text(d => d);
            
            yield svg.node();
            await promiseTick(2500);
        }
    }
    
    // === CODE ====
    
    var gen = f(), done = true;
    /*
    function animate() {
        if (done == true) {
            done = false;
            gen.next().then((v) => { 
                done = true;
                console.log("v: " + v.value);
                document.getElementById("container").innerHTML = v.value;
            });
        }
        requestAnimationFrame(animate);
    };
    
    document.onload = animate;
    */
    
    document.body.onload = function() {
        const container = document.getElementById("container");

        function write_to_container(v) {
            console.log("write_to_container (" + v.value + ")");
            container.firstChild.remove();
            container.appendChild(v.value);
            gen.next().then(write_to_container);
        };

        gen.next().then(function(v) { 
            container.appendChild(v.value);
            gen.next().then(write_to_container);
        });
    };
</script>
</html>
